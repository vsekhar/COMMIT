-- Schema hierarchy:
-- + Batches
--   + Log
-- + Decisions
--   + Actions

-- Log contains the log entries.
--
-- Spanner will split Log based on Region (to reduce network latency) and
-- prefixes of DataSHA3512.
--
-- --------------------------------
-- Appending new entries to the log
-- --------------------------------
--
-- DataSHA3512 is first computed using the 64-byte value provided by the user
-- and the 64-byte salt generated by the server (and returned to the user). The
-- timestamp is the Spanner commit timestamp (also returned to the user).
--
-- To determine the SequenceNo and the RecordSHA3512, we first compute two
-- prefixes by splitting DataSHA3512 as follows:
--
--   Index:    0 1 2 3 4 5 6 ... == DataSHA3512[0:64]
--   Prefix1: |0 1|2 3|          == DataSHA3512[0:4]
--            |0 1|   |4 5|
--              |   ┌───┘
--   Prefix2: |0 1|4 5|          == append(DataSHA3512[0:2], DataSHA3512[4:6])
--
-- Generally, for prefix length N (which must be even):
--
--   Prefix1 = DataSHA3512[0:N]
--   Prefix2 = append(DataSHA3512[0:N/2], DataSHA3512[N:N+N/2])
--
-- This ensures that the two prefix chains we will use later are close to each
-- other in the key space and thus likely (especially early on) to reside on the
-- same server. These prefixes are used below.
--
-- SequenceNo is one larger than the most recent SequenceNo in Prefix1.
--
-- Based on the SequenceNo, the new entry can be either an MMR leaf or non-leaf.
-- If the new entry is a non-leaf, its predecessors are 
--
--   Leaf:
--     Predecessor1 = most recent entry in Prefix1
--     Predecessor2 = most recent entry in Prefix2
--
--   Non-leaf:
--     Predecessor1 = right child in Prefix1 (SequenceNo-1)
--     Predecessor2 = left child in Prefix1
--
-- RecordSHA3512 is determined by hashing in order:
--
--   1) RecordSHA3512 of Predecessor1
--   2) RecordSHA3512 of Predecessor2
--   3) DataSHA3512
--   4) Timestamp
--
-- If a predecessor does not exist, it is omitted from the hash.
--
-- Because Timestamp is included in this hash, RecordSHA3512 must be added to
-- the entry after the entry is initially written. This introduces a possibility
-- that some entries will not have a RecordSHA3512, if the writer fails between
-- the first and second write. However, RecordSHA3512 is entirely determined by
-- the other fields that are written on the first write: DataSHA3512, SequenceNo
-- (which decides predecessors) and Timestamp. So encountering an entry without
-- a RecordSHA3512 can be resolved by simply computing it at the time it is
-- needed and writing it to the entry.
--
-- DigestSHA3512 holds a rolling digest of the entire prefix chain (as an MMR)
-- as of the moment when that entry was added. It is determined by hashing in
-- order:
--
--   1) RecordSHA3512 of all peaks to the left of the current entry, as computed
--      using the new entry's SequenceNo
--   2) RecordSHA3512 of the new entry
--
-- As with RecordSHA3512, DigestSHA3512 is added on the second write. If an
-- entry does not receive its DigestSHA3512 when initially written, it can be
-- lazily added later.
--
-- RecordSHA3512 and DigestSHA3512 attached to old entries can be deleted to
-- save space.
--
-- --------------------------------------------
-- Creating a digest of the full (regional) log
-- --------------------------------------------
--
-- The log logically consists of 2^(8N) prefix chains that each comprise an MMR.
--
-- The prefix length N determines how many prefix chains are active in the
-- region: higher N increases write throughput but also increases the number of
-- digests that must be reported.
--
-- For N=2, assuming two servers/groups are involved in every write and 100 QPS
-- per Spanner group, we have an upper bound of 65,536/2 * 100 = 3.2M QPS per
-- region. Additional smaller regions can increase overall throughput.
--
-- The digest for a prefix chain can be obtained by consulting the last entry in
-- that chain, or any earlier entry representing the point in time of interest.
--
-- A digest of a prefix chain can be externally reported as:
--
--     <region>:<prefix>:<number of entries in chain>:<last timestamp>:<SHA3512>
-- e.g. NA:ZUU:15673:6546516847616981651689135662165804354685:2wYM0X+pRKcMp1WjriLOcmGQbZtL9Vt0JckBCu86eA9WuD6kHhh0T7+tXWHuTzPVju+oy6DeRoEJDTjqWXxpJQ
--
-- The binary values <prefix> and <SHA3512> are URL-safe base64-encoded (RFC
-- 4648 §5) with no padding. Timestamp is encoded as nanoseconds from
-- 0001-01-01 00:00:00 UTC.
--
-- The digest of a full (regional) log can be computed by gathering digests of
-- prefix chains at some point in time. This is best done by reading some time
-- in the past. Spanner ensures we get a consistent view of the entire log
-- globally when performing this read.
--
-- The digest of a regional log can be reported as:
--
--      <region>:<number of entries in region>:<last timestamp>:<SHA3512>
-- e.g. NA:116575673:6546516847616981651689135662165804354685:9w/cdNba+DmCdXnIAhhF/c4W2fDTUT1reavvujhzX1hOzfSZ2hyLz4KdlLkzMilXd6Qqh19f613YYNs4hpZ4Tw
--
-- The digest of the global log can be assembed from regional logs and reported
-- as:
--
--       <number of entries globally>:<last timestamp>:<SHA3512>
-- e.g.  41166575673:6546516847616981651689135662165804354685:Lh7Zv0z6McRkZmmlgCUznzbIastGxKHGDH8qOdOG5w0QIGDsOZmB19SYb53TH56gaEgm481o6acodXTVH0DZNg
--
-- Prefix, regional and global digests are computed and signed by the
-- infrastructure.
--
-- This digest is signed by the infrastructure, and the digest and signature are
-- hashed and themselves committed to the log. This means that anyone in
-- posesssion of a prior digest can request a proof that that digest was
-- included in any future one. The digest, its signature and the DataSHA3512 and
-- salt of its commitment are published.
--
-- TODO: What if multiple possible digests were created and committed and we
-- later shift around which one we claim is real? Signature solves that?
--
-- We can recreate this digest at any time in the future by doing time-specific
-- reads in the past at the desired timestamp: Spanner guarantees we will see an
-- externally consistent view of the database as it was at that time in the
-- past. Verifiers can do this themselves offline by simply filtering out
-- entries with timestamps later than the digest timestamp.
--
-- Creating digests makes heavy use of caching of the following entries:
--
--   * The RecordSHA3512 of the peaks of a prefix chain
--     * older/taller peaks remain among an MMR's peaks for a long time
--     * new tall peaks are known by the their SequenceNo, can be pre-emptively
--       cached
--   * The digest of each prefix chain at a given SequenceNo and Timestamp
--   * The digest of the log at a given Timestamp
--
-- -----------------------------
-- Proving inclusion of an entry
-- -----------------------------
--
-- Users request proofs of an entry by its DataSHA3512.
--
-- TODO: Would a user have any reason to know or use the RecordSHA3512?
--
-- TODO: What is N? How does it evolve? Ok to start with some obscenely high
-- number? We're just computing predecessors for leaves, trees are otherwise

-- NB: Cannot have a table higher in the hierarchy than Log (e.g. "Prefixes")
-- since it would limit Log to 4GB per prefix (min. 250k prefixes to hold 1PB).

-- Write new values spread across prefixes, which requires also quickly looking
-- up the most recent value to compute the new SequenceNo and recent and prior
-- values when computing DigestSHA3512.
CREATE TABLE Log (
    Region                STRING(MAX) NOT NULL,
    Prefix                BYTES(64) NOT NULL,
    SequenceNo            INT64 NOT NULL,
    DataSHA3512           BYTES(64) NOT NULL,
    RecordSHA3512         BYTES(64),
    DigestSHA3512         BYTES(64),
    Timestamp             TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp=true),
) PRIMARY KEY (Region, Prefix, SequenceNo DESC);

-- Memcache:
--
--   (Region, Prefix, SequenceNo) --> RecordSHA3512
--   (Region, Prefix, SequenceNo) --> DigestSHA3512
--   (Region, Timestamp) --> N:last_timestamp:hash

-- Lookup by timestamp is done by simply reading in the past. No index needed.

-- Lookup a DataSHA3512 when responding to user queries.
--
-- This index stores Timestamp so that we can access Log via a read in the past.
-- Making this unique guards against the exceedingly unlikely possibility of
-- collision.
CREATE UNIQUE INDEX EntriesByDataSHA3512 ON Log (DataSHA3512)
  STORING (Timestamp);

-- TODO: Decision table, actions table (interleave in decision table)
