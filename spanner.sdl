-- Schema hierarchy:
-- + Batches
--   + Log
-- + Decisions
--   + Actions

-- Log contains the log entries.
--
-- Spanner will split Log based on Region (to reduce network latency) and hash
-- prefixes.
--
-- Entries are written in a transaction that first queries for the SequenceNo of the
-- last entry with the same N-byte prefix of DataSHA3512 and then writes the new value.
-- This transaction should involve only one Spanner split.
--
-- If the new entry is a non-leaf (as determined by its SequenceNo), then its
-- predecessors are its children within the same prefix treeas defined by a binary MMR.
--
-- If the new entry is a leaf then its predecessor is the most recent entry with
-- N-byte prefix corresponding to INT(prefix)+1. This entry will most often be on the
-- same split server.
--
-- TODO: What is N? How does it evolve? Ok to start with some obscenely high number?
-- We're just computing predecessors for leaves, trees are otherwise 
CREATE TABLE Log (
    Region                STRING(MAX),
    DataSHA3512           BYTES(MAX),
    Timestamp             TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp=true),
    SequenceNo            INT64,
    RecordSHA3512         BYTES(MAX),
) PRIMARY KEY (Region, DataSHA3512);

-- For user requests of information/proofs for a given DataSHA3512.
CREATE INDEX EntriesByDataSHA3512 ON Log (DataSHA3512) STORING (Timestamp);

-- Lazily populated sequencing for inclusion proofs.
CREATE TABLE InclusionTree (
    Region              STRING(MAX),
    InclusionSequenceNo INT64,
    RecordSHA3512       BYTES(MAX),
) PRIMARY KEY (Region, InclusionSequenceNo);

-- Very lazily populated sequencing for time proofs.
--
-- This tree is very lazily built where the Merkle order matches the time order. It
-- can be used to verify that the time stamps are validly issued.
--
-- No index for this query is built since doing so would create a hot spot at the tail
-- end of that index where all writes would be appending recent timestamps. As a result
-- ordering in this way requires a table scan. Quering log very far in the past (10+
-- minutes) and limiting the number of rows produced will help manage performance.
--
--   SELECT *
--   FROM Log
--   WHERE Timestamp > {latest timestamp from TimeTree}
--   ORDER BY Timestamp
--   LIMIT 100;
--
--   TimeSHA3512 = hash(DataSHA3512, Timestamp, TimeSHA3512_child1, TimeSHA3512_child2)
--
-- This approach exploits the fact that Timestamp is derived from commit timestamps
-- and that records are only ever appended to Log.
CREATE TABLE TimeTree (
    Region         STRING(MAX),
    TimeSequenceNo INT64 NOT NULL,
    Timestamp      TIMESTAMP NOT NULL,
    TimeSHA3512    BYTES(MAX),
) PRIMARY KEY (Region, TimeSequenceNo);

-- TODO: TimeTree may never catch up at very high write loads... Even if the queries
-- can be split up, writes to TimeTree will be bottle-necked? Or will they? Sequence
-- is fixed. Use LIMIT...OFFSET? Results in multiple stacked queries?

-- TODO: Decision table, actions table (interleave in decision table)
