-- Schema hierarchy:
-- + Batches
--   + Log
-- + Decisions
--   + Actions

-- Log contains the log entries.
--
-- Spanner will split Log based on Region (to reduce network latency) and prefixes of
-- DataSHA3512.
--
-- --------------------------------
-- Appending new entries to the log
-- --------------------------------
--
-- DataSHA3512 is first computed using the 64-byte value provided by the user and the
-- 64-byte salt generated by the server (and returned to the user). The timestamp is
-- the Spanner commit timestamp.
--
-- To determine the SequenceNo and the RecordSHA3512, we first compute two prefixes
-- by splitting DataSHA3512 as follows:
--
--   Index:   0 1 2 3 4 5 6 ...     == DataSHA3512[0:64]
--   Prefix1: |-----|               == DataSHA3512[0:4]
--   Prefix2: |-|     |-|           == append(DataSHA3512[0:2], DataSHA3512[4:6])
--
-- Generally, for prefix length N (which must be even):
--
--   Prefix1=DataSHA3512[0:N]
--   Prefix2=append(DataSHA3512[0:N/2], DataSHA3512[N:N+N/2])
--
-- This ensures that the two prefix chains we will use later are close to each other
-- in the key space and thus likely (especially early on) to reside on the same server.
--
-- SequenceNo is determined by quering for the most recent entry statisfying
-- STARTS_WITH(DataSHA3512, Prefix1) and adding one to its SequenceNo.
--
-- Based on the SequenceNo, the new entry can be either an MMR leaf or non-leaf. If
-- the new entry is a non-leaf, its predecessors are 
--
--   Leaf:
--     Predecessor1 = most recent entry satisfying STARTS_WITH(DataSHA3512, Prefix1)
--     Predecessor2 = most recent entry satisfying STARTS_WITH(DataSHA3512, Prefix2)
--
--   Non-leaf:
--     Predecessor1 = right child (SequenceNo-1)
--     Predecessor2 = left child
--
-- DigestSHA3512 holds a rolling digest of the entire prefix chain (as an MMR) as of
-- the moment when that entry was added. It is determined by hashing in order:
--
--   1) DigestSHA3512 of all peaks to the left of the current entry, as computed using
--      the new entry's SequenceNo
--   2) DigestSHA3512 of the new entry's Predecessor1
--   3) DigestSHA3512 of the new entry's Predecessor2
--   4) DataSHA3512 of the new entry
--   5) Timestamp of the new entry
--
-- --------------------------------------------
-- Creating a digest of the full (regional) log
-- --------------------------------------------
--
-- The log logically consists of 2^(8N) prefix chains that each comprise an MMR.
--
-- The prefix length N determines how many prefix chains are active in the region:
-- higher N increases write throughput but also increases the number of digests that
-- must be reported.
--
-- For N=2, assuming two servers/groups are involved in every write and 100 QPS per
-- Spanner group, we have an upper bound of 65,536/2 * 100 = 3.2M QPS per region.
-- Additional smaller regions can increase overall throughput.
--
-- The digest for a prefix chain can be obtained by consulting the last entry in that
-- chain, or any earlier entry representing the point in time of interest.
--
-- A digest of a prefix chain can be externally reported as:
--
--        <region>:<prefix>:<number of entries in chain>:<last timestamp>:<SHA3512>
--   e.g. NA:ZUU:15673:6546516847616981651689135662165804354685:2wYM0X+pRKcMp1WjriLOcmGQbZtL9Vt0JckBCu86eA9WuD6kHhh0T7+tXWHuTzPVju+oy6DeRoEJDTjqWXxpJQ
--
-- The binary values <prefix> and <SHA3512> are URL-safe base64-encoded (RFC 4648 ยง5)
-- with no padding. Timestamp is encoded as nanoseconds from 0001-01-01 00:00:00 UTC.
--
-- The digest of a full (regional) log can be computed by gathering digests of prefix
-- chains at some point in time. This is best done by reading some time in the past.
-- Spanner ensures we get a consistent view of the entire log globally when performing
-- this read.
--
-- The digest of a regional log can be reported as:
--
--        <region>:<number of entries in region>:<last timestamp>:<SHA3512>
--   e.g. NA:116575673:6546516847616981651689135662165804354685:9w/cdNba+DmCdXnIAhhF/c4W2fDTUT1reavvujhzX1hOzfSZ2hyLz4KdlLkzMilXd6Qqh19f613YYNs4hpZ4Tw
--
-- The digest of the global log can be assembed from regional logs and reported as:
--
--         <number of entries globally>:<last timestamp>:<SHA3512>
--   e.g.  41166575673:6546516847616981651689135662165804354685:Lh7Zv0z6McRkZmmlgCUznzbIastGxKHGDH8qOdOG5w0QIGDsOZmB19SYb53TH56gaEgm481o6acodXTVH0DZNg
--
-- Prefix, regional and global digests are computed and signed by the infrastructure.
--
-- TODO: Rolling digest is a problem when generating proofs. It effectively chains
-- entries (O(N) proof distance) rather than puts then in a tree (O(logN) proof distance).
--
-- Rolling digest is useless as soon as the next one is produced. It is not a
-- constituent in any further proof. Include both RecordSHA3512 and DigestSHA3512?
--
-- TODO: why commit the digest?
--
-- This digest is signed by the infrastructure, and the digest and signature are hashed
-- and themselves committed to the log. This means that anyone in posesssion of a prior
-- digest can request a proof that that digest was included in any future one. The
-- digest, its signature and the DataSHA3512 and salt of its commitment are published.
--
-- We can recreate this digest at any time in the future by doing time-specific reads
-- in the past at the desired timestamp: Spanner guarantees we will see an externally
-- consistent view of the database as it was at that time in the past. Verifiers can do
-- this themselves offline by simply filtering out entries with timestamps later than
-- the digest timestamp.
--
-- Creating digests makes heavy use of caching of the following entries:
--
--   * The RecordSHA3512 of the peaks of a prefix chain
--     * older/taller peaks remain among an MMR's peaks for a long time
--     * new tall peaks are known by the their SequenceNo, can be pre-emptively cached
--   * The digest of each prefix chain at a given SequenceNo and Timestamp
--   * The digest of the log at a given Timestamp
--
-- -----------------------------
-- Proving inclusion of an entry
-- -----------------------------
--
-- Users request proofs of an entry by its DataSHA3512.
--
-- TODO: Would a user have any reason to know or use the RecordSHA3512?
--
-- TODO: What is N? How does it evolve? Ok to start with some obscenely high number?
-- We're just computing predecessors for leaves, trees are otherwise

-- Write new values spread across prefixes, which requires also quickly looking up
-- the most recent value to compute the new SequenceNo and recent and prior values
-- when computing DigestSHA3512.
CREATE TABLE Log (
    Region                STRING(MAX),
    Prefix                BYTES(MAX),
    SequenceNo            INT64,
    DataSHA3512           BYTES(MAX),
    DigestSHA3512         BYTES(MAX),
    Timestamp             TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp=true),
) PRIMARY KEY (Region, Prefix, SequenceNo DESC);

-- Lookup a DataSHA3512 when responding to user queries.
--
-- NB: Region appears so that the index can be split onto servers closer to users
-- using it; we expect DataSHA3512 to be globally unique.
CREATE INDEX EntriesByDataSHA3512 ON Log (Region, DataSHA3512)
  STORING (SequenceNo, DigestSHA3512);

-- TODO: Decision table, actions table (interleave in decision table)
